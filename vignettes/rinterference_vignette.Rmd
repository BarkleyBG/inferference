---
title: "RInterference Vignette"
author: 
- name : "Bradley Saul"
  affiliation: "University of North Carolina"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{RInterference Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
abstract:  
A vaccine may protect the treated person as well as others in their social network. ANOTHER EXAMPLE. In causal inference, this phenomena is known as interference: the treatment of one unit affects the outcomes of other units. Stratified interference assumes that (a) individuals can be grouped such that no interference occurs between groups and (b) an individual's outcome depends on the proportion treated within their group. The R package described in this paper, rinterference, uses group-level inverse probability weights (IPW) to compute causal effect estimates. Examples from political sciences and infectious disease illustrate use of the package. Out-of-the-box tools offer a range of options, but researchers can also define their own functions to define the group-level propensity score.
---


# OLD BELOW

This is a VERY brief description of how to use the `rinterference` package.

```{r, echo = TRUE}
library(rinterference)
```

I have included a simple dataset generated from `rinterferenceSim` package: 3000 units, 250 groups, 2 covariates, 21 allocations (0 to 1 by 0.05), using the parameters in the code below. See Perez 2014 for details on how the simulations were structured.


```{r, echo=TRUE, eval=FALSE}
alphaz = seq(0, 1, by=.05) # needed to compute truth
theta.base <- c(.5, -0.788, -2.953, -0.098, -0.145, 0.351)
theta.sim <- c(0.2727, -0.0387, .2719, 1.0859)
sample_sim <- sim_interference(n = 3000, N = 250, nsims = 1, 
                               base.parameters = theta.base, 
                               parameters = theta.sim,
                               alphas = alphaz)
interference_sample <- sample_sim$sims[[1]]
#save(sample_data, file = "data/sample_data.rda")
```

Here's what the data looks like:
```{r}
head(interference_sample)
```

y is the outcome. X1 and X2 are covariates. A is the randomized treatment indicator. B is an indicator of participation in the trial. Group is obvious.

The `rinterference` package has two main steps. First is to calculate all the pieces of the IPW estimators. `run_interference()` does this. Using these pieces, you want to compute the effects and associated variances. `calc_effect()` does this. `direct_effect()`, `indirect_effect()`, `total_effect()` and `overall_effect()` are convenient wrappers for `calc_effect` to get.

Here's a quick sample of `run_interference()` based on the data provided:
```{r, echo=TRUE}
sample_run <- interference(
  allocations = c(.3, .45, .6),
  data = interference_sample, # name of the data frame
  groups = 'group',   # quoted string with group variable
  outcome = 'y',      # quoted string with outcome variable
  treatment = 'A', # quote string of treatment variable
  propensityB = 'B', # quoted string for 'first stage' variable. OPTIONAL.
  propensity_formula = B ~ X1 + X2 + (1|group),
  randomization = 2/3,
  method = 'simple')
```

Now we can compute the effects:

```{r, echo = TRUE}
#Compute DE(.3)
summary(sample_run)
```

Let's say we're running simulations and we know the true parameters. In the sample above, the parameters were estimated by `glmer`, but we can tell `run_interference` that we know the truth via the `known_params` argument. Be careful that the number of parameters line up with the number of parameters expected by the integrand function. In the case of `logit_integrand`, the default integrand function, it expects an intercept parameter, one for each covariate, and one for the random effect. 

```{r, echo = TRUE, eval=FALSE}
sample_run_truth <- interference(
  data = sample_data, # name of the data frame
  groups = 'group',   # quoted string with group variable
  outcome = 'y',      # quoted string with outcome variable
  treatment = 'A', # quote string of treatment variable
  propensityB = 'B', # quoted string for 'first stage' variable. OPTIONAL.
  propensity_formula = B ~ X1 + X2 + (1|group),
  randomization = 2/3,
  estimation_method = 'oracle',
  estimate_options = list(fixed.effects = c(0.2727, -0.0387, .2719), 
                      random.effects = 1.0859),
  method = 'simple', # passed to grad()
  allocations = c(.3, .45, .6))
```

Now we can compute the effects:

```{r, echo = TRUE, eval=FALSE}
summary(sample_run_truth)
```

You can define your own integrand as a function and pass it as an argument to `run_interference` if desired. It would be helpful to look at the code for `logit_integrand` to get started. 